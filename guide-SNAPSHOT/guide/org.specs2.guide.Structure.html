<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <style type="text/css" media="all">
        @import url('./../../css/maven-base.css');
        @import url('./../../css/maven-theme.css');
      </style>
      <link type="text/css" rel="stylesheet" href="./../../css/prettify.css" />
      <script type="text/javascript" src="./../../css/prettify.js"></script>
      <link type="text/css" media="print" rel="stylesheet" href="./../../css/print.css" />
      <link type="text/css" rel="stylesheet" href="./../../css/tooltip.css" />
      <link type="text/css" rel="stylesheet" href="./../../css/specs2-user.css" />

      <script type="text/javascript" src="./../../css/jquery.js"></script>
      <script type="text/javascript" src="./../../css/jquery.cookie.js"></script>
      <script type="text/javascript" src="./../../css/jquery.hotkeys.js"></script>
      <script type="text/javascript" src="./../../css/jquery.jstree.js"></script>
      <script type="text/javascript" src="./../../css/tooltip.js"></script>
      <script language="javascript">
      function init() {  prettyPrint(); };
      /* found on : http://www.tek-tips.com/faqs.cfm?fid=6620 */
      String.prototype.endsWith = function(str) { return (this.match(str+'$') == str) };
      function changeWidth(id,width) {  document.getElementById(id).style.width = width; };
      function changeMarginLeft(id, margin) { document.getElementById(id).style.marginLeft = margin; };
      function toggleImage(image) {
        if (image.src.endsWith('images/expanded.gif')) 
          image.src = 'images/collapsed.gif';
        else 
          image.src = 'images/expanded.gif';
      };
      function showHide(id) {
        element = document.getElementById(id);
        element.style.display = (element.style.display == 'block')? 'none' : 'block';
      };
      function showHideByClass(name) {
		    var elements = document.getElementsByClassName(name);
        for (i = 0; i < elements.length; i++) {
		      elements[i].style.display = (elements[i].style.display == 'none') ? elements[i].style.display = '': 'none';
        }
      };
      function showByClass(name) {
        var elements = document.getElementsByClassName(name);
        for (i = 0; i < elements.length; i++) {
          elements[i].style.display = 'block';
        }
      };
      function hideByClass(name) {
        var elements = document.getElementsByClassName(name);
        for (i = 0; i < elements.length; i++) {
          elements[i].style.display = 'none';
        }
      };
      function showById(id) {
        document.getElementById(id).style.display = ''
      };
      function hideById(id) {
        document.getElementById(id).style.display = 'none'
      };
    </script>
      <script language="javascript">window.onload=init;</script>
      <!-- the tabber.js file must be loaded after the onload function has been set, in order to run the
           tabber code, then the init code -->
      <script type="text/javascript" src="./../../css/tabber.js"></script>
      <link type="text/css" media="screen" rel="stylesheet" href="./../../css/tabber.css" />
    </head><body><div id="breadcrumbs"><a href="../../guide-SNAPSHOT/guide/org.specs2.UserGuide.html">UserGuide</a><t> / </t><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html">Structure</a></div><div id="leftcolumn"><div id="tree">
      <ul><li id="491306744"><a href="../../guide-SNAPSHOT/guide/org.specs2.UserGuide.html#User+Guide">User Guide</a>
            <ul><li id="1583260057"><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.QuickStart.html#Quick+Start">Quick Start</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.QuickStart.html#Unit">Unit</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.QuickStart.html#Acceptance">Acceptance</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.QuickStart.html#Execution">Execution</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.QuickStart.html#And+much+more%21">And much more!</a>
            
          </li></ul>
          </li><li id="132777728"><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Structure">Structure</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Presentation">Presentation</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Declare+examples">Declare examples</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Styles">Styles</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Acceptance+specification">Acceptance specification</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Unit+specification">Unit specification</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Results">Results</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Standard">Standard</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Matchers">Matchers</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Expectations">Expectations</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Functional">Functional</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Thrown">Thrown</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#All">All</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Short-circuit">Short-circuit</a>
            
          </li></ul>
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Pending+until+fixed">Pending until fixed</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Auto-Examples">Auto-Examples</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#G%2FW%2FT">G/W/T</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Multiple+steps">Multiple steps</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Extract+methods">Extract methods</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#User+regexps">User regexps</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#G%2FW%2FT+sequences">G/W/T sequences</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#ScalaCheck">ScalaCheck</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Single+step">Single step</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Conversions">Conversions</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Unit+specification">Unit specification</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#DataTables">DataTables</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Links">Links</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Inclusion">Inclusion</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Html+link">Html link</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Html+Link">Html Link</a>
            
          </li></ul>
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Reference">Reference</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Markdown+url">Markdown url</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Contexts">Contexts</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Isolation">Isolation</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Scope">Scope</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Isolated+variables">Isolated variables</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Case+classes">Case classes</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Contexts+inheritance">Contexts inheritance</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Before%2FAfter">Before/After</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#In+a+mutable+specification">In a mutable specification</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#In+an+acceptance+specification">In an acceptance specification</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Around">Around</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Outside">Outside</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#AroundOutside">AroundOutside</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#BeforeExample">BeforeExample</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Implicit+context">Implicit context</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Composition">Composition</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Combinations">Combinations</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Composition">Composition</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Steps%2FActions">Steps/Actions</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Steps">Steps</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Actions">Actions</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Template">Template</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Execution">Execution</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Layout">Layout</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Rules">Rules</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Formatting+fragments">Formatting fragments</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Separating+groups+of+examples">Separating groups of examples</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Reset+the+levels">Reset the levels</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Changing+the+indentation+level">Changing the indentation level</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Combinations">Combinations</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Turning-off+the+automatic+layout">Turning-off the automatic layout</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Unit+specification">Unit specification</a>
            
          </li></ul>
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Unit+specifications">Unit specifications</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#How+to%3F">How to?</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Declare+arguments">Declare arguments</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Pass+arguments">Pass arguments</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Add+a+title">Add a title</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Use+descriptions">Use descriptions</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Enhance+failures">Enhance failures</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Share+examples">Share examples</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Create+an+index">Create an index</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Tag+examples">Tag examples</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#In+a+unit+specification">In a unit specification</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Skip+examples">Skip examples</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Debug+statements">Debug statements</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Structure.html#Remove+implicits">Remove implicits</a>
            
          </li></ul>
          </li></ul>
          </li><li id="1562677347"><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Matchers">Matchers</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Boolean+results">Boolean results</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Standard+results">Standard results</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Combinators">Combinators</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Match+results">Match results</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Out+of+the+box">Out of the box</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Optional">Optional</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Custom">Custom</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#With+sequences">With sequences</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#ScalaCheck">ScalaCheck</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Arbitrary+instances">Arbitrary instances</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#With+Generators">With Generators</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Test+properties">Test properties</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Mock+expectations">Mock expectations</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Creation+and+settings">Creation and settings</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Stubbing">Stubbing</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Mocking+and+Stubbing+at+the+same+time">Mocking and Stubbing at the same time</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#With+matchers">With matchers</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Callbacks">Callbacks</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Parameters+for+the+answers+function">Parameters for the answers function</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Verification">Verification</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Order+of+calls">Order of calls</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Ignoring+stubs">Ignoring stubs</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Spies">Spies</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Functions%2FPartialFunctions">Functions/PartialFunctions</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Auto-boxing">Auto-boxing</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Byname">Byname</a>
            
          </li></ul>
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#DataTables">DataTables</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Forms">Forms</a>
            <ul><li id="95021179"><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Forms">Forms</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Fields">Fields</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Effects">Effects</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Properties">Properties</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Styles">Styles</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Simple+form">Simple form</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Adding+several+rows+at+once">Adding several rows at once</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Nesting+a+Form+into+another+Form">Nesting a Form into another Form</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Nesting+a+Form+into+an+Effect+or+a+Prop">Nesting a Form into an Effect or a Prop</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Using+tabs">Using tabs</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Aggregating+forms">Aggregating forms</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Lazy+cells">Lazy cells</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Xml+cells">Xml cells</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#1-n+relationships">1-n relationships</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Subset">Subset</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Subsequence">Subsequence</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Set">Set</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Sequence">Sequence</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Forms.html#Decision+tables">Decision tables</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Outside+specs2">Outside specs2</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Matchers.html#Without+any+dependency+on+specs2">Without any dependency on specs2</a>
            
          </li></ul>
          </li></ul>
          </li><li id="1965953241"><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Runners">Runners</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Presentation">Presentation</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Dependencies">Dependencies</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Arguments">Arguments</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#API">API</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Most%2FLeast+frequently+used+arguments">Most/Least frequently used arguments</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Shortcuts">Shortcuts</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Output+directory">Output directory</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Storing+previous+results">Storing previous results</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Status+flags">Status flags</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Diffs">Diffs</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#StackTraceFilter">StackTraceFilter</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Command+line">Command line</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#System+properties">System properties</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#In+the+shell">In the shell</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Console+output">Console output</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Html+output">Html output</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#JUnit+XML+output">JUnit XML output</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Files+Runner">Files Runner</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#In+the+console">In the console</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Via+SBT">Via SBT</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#with+sbt+0.7.x">with sbt 0.7.x</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#with+sbt+%3E+0.9.x">with sbt &gt; 0.9.x</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Test-only+arguments">Test-only arguments</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Output+formats">Output formats</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Files+runner">Files runner</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Colors">Colors</a>
            
          </li></ul>
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Via+IDEA">Via IDEA</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Via+JUnit">Via JUnit</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Arguments">Arguments</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Via+Eclipse">Via Eclipse</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Via+Maven">Via Maven</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#With+your+own">With your own</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Notifier">Notifier</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#NotifierRunner">NotifierRunner</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#In+sbt">In sbt</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#Exporter">Exporter</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Runners.html#In+sbt">In sbt</a>
            
          </li></ul>
          </li></ul>
          </li></ul>
          </li><li id="590895065"><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Philosophy">Philosophy</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#The+origins">The origins</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#The+score">The score</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Conciseness">Conciseness</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Readability">Readability</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Extensibility">Extensibility</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Configuration">Configuration</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Clear+implementation">Clear implementation</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#User+support">User support</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#A+new+hope">A new hope</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Functional+%2F+immutable">Functional / immutable</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Chaining+everything">Chaining everything</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Arguments+have+to+be+supplied">Arguments have to be supplied</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Concurrency+is+a+breeze">Concurrency is a breeze</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#A+simple+structure">A simple structure</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Contexts">Contexts</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Indentation">Indentation</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Operators">Operators</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Forms">Forms</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#But+if+you+STILL+want+mutable+specifications">But if you STILL want mutable specifications</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Dependencies+control">Dependencies control</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Philosophy.html#Implicit+definitions+control">Implicit definitions control</a>
            
          </li></ul>
          </li></ul>
          </li><li id="109507208"><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Design.html#Design">Design</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Design.html#Presentation">Presentation</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Design.html#Structure">Structure</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Design.html#Creation">Creation</a>
            <ul><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Design.html#Creating+Fragments">Creating Fragments</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Design.html#Mutable+Specification">Mutable Specification</a>
            
          </li></ul>
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Design.html#Execution">Execution</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Design.html#Reporting">Reporting</a>
            
          </li><li id=""><a href="../../guide-SNAPSHOT/guide/org.specs2.guide.Design.html#Dependencies">Dependencies</a>
            
          </li></ul>
          </li></ul>
          </li></ul>
      <script>$(function () {	$('#tree').jstree({'core':{'initially_open':['491306744','132777728'], 'animation':200}, 'plugins':['themes', 'html_data']}); });</script>
    </div></div><div id="central"><title>Structure</title><a name="Structure"><h2 specId="132777728">Structure</h2></a><status class="ok"><div class="level0" style="display: show"><a name="Presentation"><h3>Presentation</h3></a><p>In this page you will learn how to:</p>
<ul>
  <li>declare examples and expectations</li>
  <li>link specifications together</li>
  <li>define contexts and actions to execute before/after examples</li>
  <li>specify the execution strategy</li>
  <li>layout the specification text</li>
</ul><a name="Declare+examples"><h3>Declare examples</h3></a><a name="Styles"><h4>Styles</h4></a><p>The <a href="org.specs2.guide.QuickStart.html">Quick Start</a> guide describes 2 styles of specifications, the <em>unit</em> style and the <em>acceptance</em> style. Both styles actually build a specification as a list of <em>fragments</em>.</p><a name="Acceptance+specification"><h5><em>Acceptance</em> specification</h5></a><p>In an <em>acceptance</em> specification you build a list of <em>fragments</em> with the <code class="prettyprint">^</code> operator:</p>
<pre><code class="prettyprint">  &quot;this is my specification&quot;                          ^
    &quot;and example 1&quot;                                   ! e1^
    &quot;and example 2&quot;                                   ! e2

  def e1 = success
  def e2 = success
</code></pre><p>What we have here is a list of 3 fragments, a Text fragment and 2 Example fragments. The examples are declared using the<br />format <code class="prettyprint">&quot;description&quot; ! body</code>. Their &quot;bodies&quot; are provided by 2 methods returning a <code class="prettyprint">Result</code>, separated from the specification text.</p><p>There is no specific recommendation on how you should name those methods but you can either use short names or use the backtick<br />notation for better readability:</p>
<pre><code class="prettyprint">  &quot;this is my specification&quot;                          ^
    &quot;and example 1&quot;                                   ! `first example`^
    &quot;and example 2&quot;                                   ! `second example`

  def `first example` = success
  def `second example` = success
</code></pre><p>You can even push this idea further by writing:</p>
<pre><code class="prettyprint">  &quot;this is my specification&quot;                          ^
    `and example 1`                                   ^
    `and example 2`

  def `and example 1` = success
  def `and example 2` = success
</code></pre><p><em>(an IDE with good refactoring capabilities is a must-have in that case,...)</em></p><a name="Unit+specification"><h5><em>Unit</em> specification</h5></a><p>A <em>unit</em> specification uses <code class="prettyprint">should/in</code> blocks which build the Fragments by adding them to a mutable protected variable:</p>
<pre><code class="prettyprint">  &quot;The 'Hello world' string&quot; should {
    &quot;contain 11 characters&quot; in {
      &quot;Hello world&quot; must have size(11)
    }
    &quot;start with 'Hello'&quot; in {
      &quot;Hello world&quot; must startWith(&quot;Hello&quot;)
    }
    &quot;end with 'world'&quot; in {
      &quot;Hello world&quot; must endWith(&quot;world&quot;)
    }
  }
</code></pre><p>In that specification the following methods are used:</p>
<ul>
  <li><code class="prettyprint">in</code> to create an Example containing a <code class="prettyprint">Result</code></li>
  <li><code class="prettyprint">should</code> to create a group of Examples, with a the preceding Text fragment appended with <code class="prettyprint">should</code></li>
</ul><p>It is completely equivalent to writing this in an <code class="prettyprint">org.specs2.Specification</code>:</p>
<pre><code class="prettyprint">  def is =

  &quot;The 'Hello world' string should&quot; ^
    &quot;contain 11 characters&quot; ! {
      &quot;Hello world&quot; must have size(11)
    }^
    &quot;start with 'Hello'&quot; ! {
      &quot;Hello world&quot; must startWith(&quot;Hello&quot;)
    }^
    &quot;end with 'world'&quot; ! {
      &quot;Hello world&quot; must endWith(&quot;world&quot;)
    }
</code></pre><p>The <a href="#Unit+specifications">Unit specifications</a> section shows all the methods which can be used to build unit specifications fragments.</p><a name="Results"><h4>Results</h4></a><p>An Example is created by following a piece of text with <code class="prettyprint">!</code> and providing anything convertible to an <code class="prettyprint">org.specs2.execute.Result</code>:</p>
<ul>
  <li>a standard result</li>
  <li>a Matcher result</li>
  <li>a boolean value</li>
</ul><a name="Standard"><h5>Standard</h5></a><p>The simplest <code class="prettyprint">Result</code> values are provided by the <code class="prettyprint">StandardResults</code> trait (mixed-in with <code class="prettyprint">Specification</code>), and match the 5<br />types of results provided by <strong><em>specs2</em></strong>:</p>
<ul>
  <li><code class="prettyprint">success</code>: the example is ok</li>
  <li><code class="prettyprint">failure</code>: there is a non-met expectation</li>
  <li><code class="prettyprint">anError</code>: a unexpected exception occurred</li>
  <li><code class="prettyprint">skipped</code>: the example is skipped possibly at runtime because some conditions are not met</li>
  <li><code class="prettyprint">pending</code>: usually means &quot;not implemented yet&quot;</li>
</ul><p>Two additional results are also available to track the progress of features:</p>
<ul>
  <li><code class="prettyprint">done</code>: a <code class="prettyprint">Success</code> with the message &quot;DONE&quot;</li>
  <li><code class="prettyprint">todo</code>: a <code class="prettyprint">Pending</code> with the message &quot;TODO&quot;</li>
</ul><a name="Matchers"><h5>Matchers</h5></a><p>Usually the body of an example is made of <em>expectations</em> using matchers:</p>
<pre><code class="prettyprint"> def e1 = 1 must_== 1
</code></pre><p>You can refer to the <a href="org.specs2.guide.Matchers.html">Matchers</a> guide to learn all about matchers and how to create expectations.</p><a name="Expectations"><h4>Expectations</h4></a><a name="Functional"><h5>Functional</h5></a><p>The default <code class="prettyprint">Specification</code> trait in <strong><em>specs2</em></strong> is functional: the Result of an example is always given by the last statement of its body. This example will never fail because the first expectation is &quot;lost&quot;:</p>
<pre><code class="prettyprint">  &quot;my example on strings&quot; ! e1                // will never fail!

  def e1 = {
    &quot;hello&quot; must have size(10000)             // because this expectation will not be returned,...
    &quot;hello&quot; must startWith(&quot;hell&quot;)
  }
</code></pre><p>So the correct way of writing the example is:</p>
<pre><code class="prettyprint">  &quot;my example on strings&quot; ! e1               // will fail

  def e1 = &quot;hello&quot; must have size(10000) and
                        startWith(&quot;hell&quot;)
</code></pre><a name="Thrown"><h5>Thrown</h5></a><p>The above functionality encourages a specification style where every expectation is carefully specified and is considered good practice by some. However you might see it as an annoying restriction. You can avoid it by mixing-in the <code class="prettyprint">org.specs2.matcher.ThrownExpectations</code> trait. With that trait, any failing expectation will throw a <code class="prettyprint">FailureException</code> and the rest of the example will not be executed.</p><p>There is also an additional method <code class="prettyprint">failure(message)</code> to throw a <code class="prettyprint">FailureException</code> at will.</p><p>Note that the <code class="prettyprint">ThrownExpectations</code> traits is mixed in the <code class="prettyprint">mutable.Specification</code> trait used for <em>unit</em> specifications and, if you wish, you revert back to <em>not</em> throwing exceptions on failed expectations by mixing-in the <code class="prettyprint">org.specs2.matcher.NoThrownExpectations</code> trait.</p><a name="All"><h5>All</h5></a><p>The <code class="prettyprint">org.specs2.specification.AllExpectations</code> trait goes further and gives you the possibility to have all the failures of an Example to be reported without stopping at the first one. This enables a type of specification where it is possible to define lots of expectations inside the body of an example and get a maximum of information on what fails and what passes:</p>
<pre><code class="prettyprint">  import org.specs2._
  import specification._

  class AllExpectationsSpec extends mutable.Specification with AllExpectations {
    &quot;In this example all the expectations are evaluated&quot; &gt;&gt; {
      1 === 2  // this fails
      1 === 3  // this also fails
      1 === 1
    }
    &quot;There is no collision with this example&quot; &gt;&gt; {
      10 === 11 // this fails
      12 === 12
      13 === 31 // this also fails
    }
  }
</code></pre><p>The second example above hints at a restriction for this kind of Specification. The failures are accumulated for each example by mutating a shared variable. &quot;Mutable&quot; means that the concurrent execution of examples will be an issue if done blindly. To avoid this, the <code class="prettyprint">AllExpectations</code> trait overrides the Specification arguments so that the Specification becomes <a href="#Isolated+variables">isolated</a> unless it is already <code class="prettyprint">isolated</code> or <code class="prettyprint">sequential</code>.</p><a name="Short-circuit"><h6>Short-circuit</h6></a><p>Ultimately, you may want to stop the execution of an example if one expectation is not verified. This is possible with <code class="prettyprint">orThrow</code>:</p>
<pre><code class="prettyprint">  &quot;In this example all the expectations are evaluated&quot; &gt;&gt; {
    1 === 1           // this is ok
   (1 === 3).orThrow  // this fails but is never executed
    1 === 4
  }
</code></pre><p>Alternatively, <code class="prettyprint">orSkip</code> will skip the rest of the example in case of a failure.</p><a name="Pending+until+fixed"><h4>Pending until fixed</h4></a><p>Some examples may be temporarily failing but you may not want the entire test suite to fail just for those examples. Instead of commenting them out and then forgetting about those examples when the code is fixed, you can append <code class="prettyprint">pendingUntilFixed</code> to the Example body:</p>
<pre><code class="prettyprint">  &quot;this example fails for now&quot; ! {
    1 must_== 2
  }.pendingUntilFixed

  // or, with a more specific message
  &quot;this example fails for now&quot; ! {
    1 must_== 2
  }.pendingUntilFixed(&quot;ISSUE-123&quot;)
</code></pre><p>The example above will be reported as <code class="prettyprint">Pending</code> until it succeeds. Then it is marked as a failure so that you can remember to remove the <code class="prettyprint">pendingUntilFixed</code> marker.</p><a name="Auto-Examples"><h4>Auto-Examples</h4></a><p>If your specification is about showing the use of a DSL or of an API, you can elid a description for the Example. This functionality is used in <strong><em>specs2</em></strong> to specify matchers:</p>
<pre><code class="prettyprint"> &quot;beNone checks if an element is None&quot;                             ^
 { None must beNone }                                              ^
 { Some(1) must not be none }                                      ^
</code></pre><p>In that case, the text of the example will be extracted from the source file and the output will be:</p>
<pre><code class="prettyprint"> beNone checks if an element is None
   + None must beNone
   + Some(1) must not be none
</code></pre><p>Auto-Examples can also be used in mutable specifications but the need to be declared by using the <code class="prettyprint">eg</code> (<em>exempli gratia</em>, the latin abbreviation for &quot;for example&quot;):</p>
<pre><code class="prettyprint"> class SomeExamples extends mutable.Specification {
   { None must beNone }.eg
   { Some(1) must not be none }.eg
 }
</code></pre><p>A few things to remember about this feature:</p>
<ul>
  <li><p>the source file is expected to be found in the <code class="prettyprint">src/test/scala</code> directory. This can be overriden by specifying the <code class="prettyprint">specs2.srcTestDir</code> system property</p></li>
  <li><p>the extraction of the source code is rudimentary and may fail on specifications which are built dynamically</p></li>
  <li><p>several lines of code can be extracted provided that the block ends with a <code class="prettyprint">Result</code> and that there is a <code class="prettyprint">Fragment</code> following the block to be extracted. The best way to ensure that is to always add an <code class="prettyprint">end</code> fragment at the end of the <code class="prettyprint">Specification</code></p></li>
  <li><p>the code to extract must be in the same directory as the package of the specification class it belongs to. If a Specification is declared in <code class="prettyprint">package com.mycompany.accounting</code> then its source file has to be in the <code class="prettyprint">com/mycompany/accounting</code> directory for Auto-Examples to be working</p></li>
  <li><p>for more robustness, but different results, you can use the <code class="prettyprint">descFromExpectations</code> argument (creates an <code class="prettyprint">args(fromSource=false)</code> argument) to take the &quot;ok message&quot; from the expectation as the example description:</p>
  <pre><code class="prettyprint"> // outputs: List(1, 2) must contain(1)
 { List(1, 2) must contain(1) }

 // outputs: 'List(1, 2)' contains '1'
 descFromExpectations ^
 { List(1, 2) must contain(1) }
</code></pre></li>
</ul></div></status><status class="ok"><div class="level0" style="display: show"><a name="G%2FW%2FT"><h4>G/W/T</h4></a><p>More sophisticated is the Given/When/Then style of writing specifications. This style is supported by interspersing Text fragments, with Given/When/Then <code class="prettyprint">RegexSteps</code> which extract meaningful values from the text. Here's an example specification for a simple calculator:</p>
<pre><code class="prettyprint">  &quot;A given-when-then example for the addition&quot;                 ^
    &quot;Given the following number: ${1}&quot;                         ^ number1 ^
    &quot;And a second number: ${2}&quot;                                ^ number2 ^
    &quot;Then I should get: ${3}&quot;                                  ^ result ^
                                                               end

  object number1 extends Given[Int] {
    def extract(text: String): Int = extract1(text).toInt
  }
  case class Addition(n1: Int, n2: Int) {
    def add: Int = n1 + n2
  }
  object number2 extends When[Int, Addition] {
    def extract(number1: Int, text: String) = Addition(number1, extract1(text).toInt)
  }
  object result extends Then[Addition] {
    def extract(addition: Addition, text: String): Result = addition.add must_== extract1(text).toInt
  }
</code></pre><p>Here's some explanation of the object definitions that support the G/W/T style:</p>
<ul>
  <li><p><code class="prettyprint">number1</code> is a <code class="prettyprint">Given</code> step. It is parametrized with the type <code class="prettyprint">Int</code> meaning that its <code class="prettyprint">extract</code> method is supposed to extract an Int from the preceding text. It does so by using the <code class="prettyprint">extract1</code> inherited method, which parses the text for <code class="prettyprint">${}</code> expressions and return a tuple (with 1 element here) containing all the values enclosed in <code class="prettyprint">${}</code>.</p></li>
  <li><p><code class="prettyprint">number2</code> is a <code class="prettyprint">When</code> step. It is paramerized with an <code class="prettyprint">Int</code>, the result from the previous extraction, and an <code class="prettyprint">Addition</code> which is the result of extracting the second number and putting the 2 together. In that case the method which must be defined is <code class="prettyprint">extract(Int, String): Addition</code>.</p></li>
  <li><p>finally the <code class="prettyprint">result</code> object defines the outcome of the Addition. Its <code class="prettyprint">extract</code> method takes an <code class="prettyprint">Addition</code> and the current text to return a <code class="prettyprint">Result</code></p></li>
</ul><a name="Multiple+steps"><h5>Multiple steps</h5></a><p>A G/W/T sequence can contain more than just 3 steps. However the compiler will check that:</p>
<ul>
  <li>only a <code class="prettyprint">Given[T]</code> extractor can start a sequence</li>
  <li>only a <code class="prettyprint">Given[S]</code>, a <code class="prettyprint">When[T, S]</code> or a <code class="prettyprint">Then[T]</code> extractor can follow a <code class="prettyprint">Given[T]</code> extractor</li>
  <li>only a <code class="prettyprint">When[T1, T2, S]</code> or a <code class="prettyprint">Then[T1, T2] can follow a sequence of</code>Given[T1], Given[T2]` extractors (up to 8 Given steps, after that types are paired)</li>
  <li>only a <code class="prettyprint">When[S, U]</code> extractor or a <code class="prettyprint">Then[S]</code> can follow a <code class="prettyprint">When[T, S]</code> extractor</li>
  <li>only a <code class="prettyprint">Then[S]</code> can follow a <code class="prettyprint">Then[S]</code> extractor</li>
</ul><p>To be more concrete, here are a few valid sequences:</p>
<ul>
  <li>Given[T] / When[T, S] / Then[S]</li>
  <li>Given[T] / Given[T2] / Given[T2] / When[T, T1, T2, R] / Then[R]</li>
  <li>Given[T] / Given[T2] / Given[T3] / Given[T4] / Then[T, T1, T2, T3, T4]</li>
  <li>Given[T] / Given[T2] / ... / Given[T8] / Then[T, T1, T2, T3, T4, T5, T6, (T7, T8)]</li>
  <li>Given[T] / When[T, S] / Then[S] / Then[S]</li>
  <li>Given[T] / Then[T] / Then[T]</li>
  <li>Given[T] / When[T, S] / When[S, U] / Then[U]</li>
</ul><a name="Extract+methods"><h5>Extract methods</h5></a><p>The <code class="prettyprint">Given</code>, <code class="prettyprint">When</code>, <code class="prettyprint">Then</code> classes provide several convenience methods to extract strings from the preceding text: the <code class="prettyprint">extract1, extract2,...</code><br /> methods will extracts the values delimited by <code class="prettyprint">${}</code> for up to 10 values.</p><a name="User+regexps"><h5>User regexps</h5></a><p>In the original way of declaring Given/When/Then steps, the text is left completely void of markers to extract meaningful values. The user then<br /> needs to specify a regular expression where groups are used to show where those values are:</p>
<pre><code class="prettyprint">  object number1 extends Given[Int](&quot;Given the following number: (.*)&quot;) {
    def extract(text: String): Int = extract1(text).toInt
  }
</code></pre><p>The advantage of using this way is that the text is left in it's pristine form, the drawback is that most of the text is duplicated in 2 places, adding more maintenance burden.</p><a name="G%2FW%2FT+sequences"><h5>G/W/T sequences</h5></a><p>Given the rule saying that only a <code class="prettyprint">Then</code> block can follow another <code class="prettyprint">Then</code> block you might think that it is not possible to start another G/W/T<br />sequence in the same specification! Fortunately it is possible by just terminating the first sequence with an <code class="prettyprint">end</code> fragment:</p>
<pre><code class="prettyprint">  &quot;A given-when-then example for the addition&quot;                 ^
    &quot;Given the following number: ${1}&quot;                         ^ number1 ^
    &quot;And a second number: ${2}&quot;                                ^ number2 ^
    &quot;Then I should get: ${3}&quot;                                  ^ addition ^
                                                               end^
  &quot;A given-when-then example for the multiplication&quot;           ^
    &quot;Given the following number: ${1}&quot;                         ^ number1 ^
    &quot;And a second number: ${2}&quot;                                ^ number2 ^
    &quot;Then I should get: ${2}&quot;                                  ^ multiplication ^
                                                               end
</code></pre><a name="ScalaCheck"><h5>ScalaCheck</h5></a><p>Once you've created a given G/W/T sequence, you can be tempted to copy and paste it in order to check the same scenario with different values. The trouble with this is the duplication of text which leads to more maintenance down the road.</p><p>This can be avoided and even enhanced by using ScalaCheck to generate more values for the same scenario. For the calculator above you could write:</p>
<pre><code class="prettyprint">  import org.scalacheck.Gen._
  import specification.gen._

  class GivenWhenThenScalacheckSpec extends Specification with ScalaCheck { def is =

    &quot;A given-when-then example for a calculator&quot;                                   ^
      &quot;Given a first number n1&quot;                                                    ^ number1 ^
      &quot;And a second number n2&quot;                                                     ^ number2 ^
      &quot;When I add them&quot;                                                            ^ add ^
      &quot;Then I should get n1 + n2&quot;                                                  ^ result ^
                                                                                   end

    object number1 extends Given[Int] {
      def extract(text: String) = choose(-10, 10)
    }
    object number2 extends When[Int, (Int, Int)] {
      def extract(number1: Int, text: String) = for { n2 &lt;- choose(-10, 10) } yield (number1, n2)
    }
    object add extends When[(Int, Int), Addition] {
      def extract(numbers: (Int, Int), text: String) = Addition(numbers._1, numbers._2)
    }
    object mult extends When[(Int, Int), Multiplication] {
      def extract(numbers: (Int, Int), text: String) = Multiplication(numbers._1, numbers._2)
    }
    object result extends Then[Addition] {
      def extract(text: String)(implicit op: Arbitrary[Addition]) = {
        check { (op: Addition) =&gt; op.calculate must_== op.n1 + op.n2 }
      }
    }
    case class Addition(n1: Int, n2: Int) extends Operation { def calculate: Int = n1 + n2 }
  }
</code></pre><p>The main differences with a &quot;normal&quot; G/W/T sequence are:</p>
<ul>
  <li>the import of step classes from <code class="prettyprint">org.specs2.specification.gen</code> instead of <code class="prettyprint">org.specs2.specification</code></li>
  <li>the return values from the <code class="prettyprint">extract</code> methods of the <code class="prettyprint">Given</code> and <code class="prettyprint">When</code> steps which must return ScalaCheck generators (cf <code class="prettyprint">number1</code> and <code class="prettyprint">number2</code>). For the <code class="prettyprint">add</code> step there is an implicit conversion transforming any value of type <code class="prettyprint">T</code> to a <code class="prettyprint">Gen[T]</code></li>
  <li>the use of the ScalaCheck trait to access the <code class="prettyprint">check</code> function transforming a function to a <code class="prettyprint">org.scalacheck.Prop</code> and then to a <code class="prettyprint">Result</code></li>
  <li>the <code class="prettyprint">extract</code> method of the <code class="prettyprint">Then</code> step takes an implicit <code class="prettyprint">Arbitrary[T]</code> parameter which is used by the <code class="prettyprint">check</code> method to create a ScalaCheck property</li>
</ul><a name="Single+step"><h5>Single step</h5></a><p>A <code class="prettyprint">GivenThen</code> step can be used to extract values from a single piece of text and return a <code class="prettyprint">Result</code>:</p>
<pre><code class="prettyprint">  &quot;given the name: ${eric}, then the age is ${18}&quot; ! new GivenThen {
    def extract(text: String) = {
      val (name, age) = extract2(text)
      age.toInt must_== 18
    }
  }
</code></pre><p>You can also use the <code class="prettyprint">so</code> object. This object provides an <code class="prettyprint">apply</code> method expecting a <code class="prettyprint">PartialFunction</code> and does the value extraction:</p>
<pre><code class="prettyprint">  import org.specs2.specification.so

  &quot;given the name: ${eric}, then the age is ${18}&quot; ! so { case (name: String, age: String) =&gt;
    age.toInt must_== 18
  }
</code></pre><a name="Conversions"><h5>Conversions</h5></a><p>Given / When / Then steps are invariant in their type parameters. This might be detrimental to reuse. For example, if you've defined a <code class="prettyprint">Then[X]</code> step to check something about a value of type <code class="prettyprint">X</code>, it would make sense to reuse the same step with a value of type <code class="prettyprint">Y</code> when <code class="prettyprint">Y &lt;: X</code>. In order to do this you can use some implicit conversions which will translate steps between types when it makes sense:</p>
<pre><code class="prettyprint">  val thenX = new Then[X] {
    def extract(x: X, s: String) = success // check something about x
  }
  // thenX can be reused as a Then[Y] step because Y &lt;: X
  val thenY: Then[Y] = thenX
</code></pre><a name="Unit+specification"><h5>Unit specification</h5></a><p>Given / When / Step can also be used in a unit specification by using the <code class="prettyprint">&lt; &lt;</code> operator and local variables:</p>
<pre><code class="prettyprint">    &quot;A given-when-then example for a calculator&quot;.txt.br

      &quot;Given the following number: ${1}&quot; &lt;&lt; { s: String =&gt;
        a = s.toInt
      }
      &quot;And a second number: ${2}&quot; &lt;&lt; { s: String =&gt;
        b = s.toInt
      }
      &quot;When I use this operator: ${+}&quot; &lt;&lt; { s: String =&gt;
        result = Operation(a, b, s).calculate
      }
      &quot;Then I should get: ${3}&quot; &lt;&lt; { s: String =&gt;
        result === s.toInt
      }
      &quot;And it should be &gt; ${0}&quot; &lt;&lt; { s: String =&gt;
        result must be_&gt;(s.toInt)
      }

    var a, b, result: Int = 0

    case class Operation(n1: Int, n2: Int, operator: String) {
      def calculate: Int = if (operator == &quot;+&quot;) n1 + n2 else n1 * n2
    }
</code></pre><p>Similarly, ScalaCheck generator and properties are supported:</p>
<pre><code class="prettyprint">    &quot;Given a first number n1&quot; &lt;&lt; {
      n1 = choose(-10, 10)
    }
    &quot;And a second number n2&quot; &lt;&lt; {
      n2 = choose(-10, 10)
    }
    &quot;When I add them&quot; &lt;&lt; {
      operation = Arbitrary {
        for (a1 &lt;- n1; a2 &lt;- n2) yield Addition(a1, a2)
      }
    }
    &quot;Then I should get n1 + n2&quot; &lt;&lt; check { (op: Addition) =&gt;
        op.calculate must_== op.n1 + op.n2
    }

    var n1, n2: Gen[Int] = null
    implicit var operation: Arbitrary[Addition] = null
</code></pre><a name="DataTables"><h4>DataTables</h4></a><p><a href="org.specs2.guide.Matchers.html#DataTables">DataTables</a> are generally used to pack lots of expectations inside one example. A DataTable which is used as a <code class="prettyprint">Result</code> in the body of an Example will only be displayed when failing. If, on the other hand you want to display the table even when successful, to document your examples, you can omit the example description and inline the DataTable directly in the specification:</p>
<pre><code class="prettyprint">  class DataTableSpec extends Specification with DataTables { def is =

    &quot;adding integers should just work in scala&quot;  ^ {
      &quot;a&quot;   | &quot;b&quot; | &quot;c&quot; |
       2    !  2  !  4  |
       1    !  1  !  2  |&gt; {
       (a, b, c) =&gt;  a + b must_== c
    }
  }
</code></pre><p>This specification will be rendered as:</p>
<pre><code class="prettyprint">  adding integers should just work in scala
  +  a | b | c |
     2 | 2 | 4 |
     1 | 1 | 2 |
</code></pre><a name="Links"><h3>Links</h3></a><p>There are 2 ways to &quot;link&quot; specifications:</p>
<ul>
  <li>by including another specification, to create a parent-child relationship</li>
  <li>by creating a reference to another specification, to create a peer relationship</li>
</ul><a name="Inclusion"><h4>Inclusion</h4></a><p>There is a simple mechanism for including a &quot;children&quot; specification in a given specification. You can simply add the child specification as if it was a simple fragment:</p>
<pre><code class="prettyprint">  &quot;This is an included specification&quot;     ^
    childSpec
</code></pre><p>Otherwise, if you want to include several specifications at once you can use the <code class="prettyprint">include</code> method:</p>
<pre><code class="prettyprint">  &quot;This is the included specifications&quot;         ^
    include(childSpec1, childSpec2, childSpec3)
</code></pre><p>The effect of doing so is that all the fragments of the children specification will be inlined in the parent one. This is exactly what is done in this page of the user guide, but with a twist</p>
<pre><code class="prettyprint">  include(xonly, new GivenWhenThenSpec)        ^
  include(xonly, exampleTextIndentation)       ^
  include(xonly, resetTextIndentation)         ^
</code></pre><p>In the code above there are specific arguments to the included specifications so that they are only displayed when there are failures.</p><a name="Html+link"><h5>Html link</h5></a><p>In order to create a User Guide such as this one, you might want the included specification to be written to another html file. In this case, you need a &quot;Link&quot;:</p>
<pre><code class="prettyprint">  link(new QuickStart)
</code></pre><p>This declaration will include the child specification so it is executed when the parent specification is executed. However during the reporting, only a Html link will be created in the parent file, referencing a separate file for the children specification. On the other hand if you &quot;hide&quot; the specification, the link will not be printed out:</p>
<pre><code class="prettyprint">  link((new QuickStart).hide)
</code></pre><a name="Html+Link"><h6>Html Link</h6></a><p>It is possible to customize the generated Html link with the following syntax:</p>
<pre><code class="prettyprint">  &quot;a &quot; ~ (&quot;quick start guide&quot;, new QuickStart)
</code></pre><p>The <code class="prettyprint">~</code> operator is used to create a <code class="prettyprint">HtmlLink</code> where:</p>
<ul>
  <li>&quot;a&quot; is the beginning of the text</li>
  <li>&quot;quick start guide&quot; is the text that will be highlighted as a url link</li>
  <li><code class="prettyprint">new QuickStart</code> is the specification to include, the url being derived from the specification class name</li>
</ul><p>Several variations are possible on this pattern, depending which part of the link you want to be highlighted:</p>
<pre><code class="prettyprint">  &quot;before text&quot; ~ (&quot;text to highlight&quot;, specification, &quot;after text&quot;)
  &quot;before text&quot; ~ (&quot;text to highlight&quot;, specification, &quot;after text&quot;, &quot;tooltip&quot;)
  &quot;text to highlight&quot; ~ specification
  &quot;text to highlight&quot; ~ (specification, &quot;after text&quot;)
  &quot;text to highlight&quot; ~ (specification, &quot;after text&quot;, &quot;tooltip&quot;)
</code></pre><a name="Reference"><h4>Reference</h4></a><p>Sometimes you just want to reference another specification without triggering its execution. For example when <a href="#Create+an+index">creating an index page</a>:</p>
<pre><code class="prettyprint">  see(new MailSenderSpec)
</code></pre><p>This will generate a html link in the main specification based on the referenced specification name. If you want to customize that link you can use the following syntax:</p>
<pre><code class="prettyprint">  &quot;before text&quot; ~/ (&quot;text to highlight&quot;, specification, &quot;after text&quot;)
  &quot;before text&quot; ~/ (&quot;text to highlight&quot;, specification, &quot;after text&quot;, &quot;tooltip&quot;)
  &quot;text to highlight&quot; ~/ specification
  &quot;text to highlight&quot; ~/ (specification, &quot;after text&quot;)
  &quot;text to highlight&quot; ~/ (specification, &quot;after text&quot;, &quot;tooltip&quot;)
</code></pre><a name="Markdown+url"><h4>Markdown url</h4></a><p>If you just want to reference the url of the html page that's being generated for a given specification in a paragraph of text, you can use the <code class="prettyprint">markdownUrl</code> method:</p>
<pre><code class="prettyprint">  &quot;For more information you can read &quot;+DetailedSpec.markdownUrl
  // or
  &quot;For more information you can read &quot;+DetailedSpec.markdownUrl(&quot;the detailed specification&quot;)
  // or
  &quot;For more information you can read &quot;+&quot;the detailed specification&quot;.markdownUrl(DetailedSpec)
</code></pre><a name="Contexts"><h3>Contexts</h3></a><p>In a specification some examples are very simple and just check that a function is behaving as expected. However other examples can be more complex and require a more elaborate set-up of data to:</p>
<ul>
  <li>to create inter-related domain objects</li>
  <li>to put the environment (database, filesystem, external system) in the appropriate state</li>
</ul><p>And there are usually 3 difficulties in doing that:</p>
<ol>
  <li><em>Variables isolation</em>: making sure that each example can be executed with its own data without being impacted by the undesired side-effects of other examples</li>
  <li><em>Before/After code</em>: running code before or after every example without repeating that code in the body of each example</li>
  <li><em>Global setup/teardown code</em>: setting some state when this could take lots of resources, so you need to do it just once before anything runs</li>
</ol><p>How does a library like <a href="http://junit.org/">JUnit</a> solves this?</p>
<ol>
  <li><em>Variables isolation</em>: for each test run a new class instance is created so that there are new &quot;fresh&quot; variables for the current test case</li>
  <li><em>Before/After code</em>: there are <code class="prettyprint">@Before</code> and <code class="prettyprint">@After</code> annotations to declare once the code that must be executed before or after each example</li>
  <li><em>Global setup/teardown code</em>: there are <code class="prettyprint">@BeforeClass</code> and <code class="prettyprint">@AfterClass</code> annotations dedicated to that kind of code</li>
</ol><p>Now let's see how this can be achieved with <strong><em>specs2</em></strong>.</p><a name="Isolation"><h4>Isolation</h4></a><p><strong><em>specs2</em></strong> solves this issue in 2 ways:</p>
<ul>
  <li>simply by relying on Scala features, by creating a new trait or a case class to open a new <code class="prettyprint">Scope</code> with fresh variables</li>
  <li>by cloning the specification on each example execution when the <code class="prettyprint">isolated</code> argument is provided</li>
</ul><a name="Scope"><h5>Scope</h5></a><p>Let's see an example of using a <code class="prettyprint">Scope</code> with a mutable specification:</p>
<pre><code class="prettyprint">  class ContextSpec extends mutable.Specification {
    &quot;this is the first example&quot; in new trees {
      tree.removeNodes(2, 3) must have size(2)
    }
    &quot;this is the first example&quot; in new trees {
      tree.removeNodes(2, 3, 4) must have size(1)
    }
  }

  /** the `trees` context */
  trait trees extends Scope {
    val tree = new Tree(1, 2, 3, 4)
  }
</code></pre><p>Each example of that specification gets a new instance of the <code class="prettyprint">trees</code> trait. So it will have a brand new <code class="prettyprint">tree</code> variable and even if this data is mutated by an example, other examples will be isolated from these changes.<br />Now you might wonder why the <code class="prettyprint">trees</code> trait is extending the <code class="prettyprint">org.specs2.specification.Scope</code> trait? The reason is that the body of an Example only accepts objects which are convertible to a <code class="prettyprint">Result</code>. By extending <code class="prettyprint">Scope</code> we can take advantage of an implicit conversion provided by the <code class="prettyprint">Specification</code> trait to convert our context object to a <code class="prettyprint">Result</code>.</p><p>Scopes are a way to create a &quot;fresh&quot; object and associated variables for each example being executed. The advantages are that:</p>
<ul>
  <li>those classes can be reused and extended</li>
  <li>the execution behavior only relies on language constructs</li>
</ul><p>However, sometimes, we wish to go for a more concise way of getting fresh variables, without having to create a specific trait to encapsulate them. That's what the <code class="prettyprint">isolated</code> argument is for.</p><a name="Isolated+variables"><h5>Isolated variables</h5></a><p>The <code class="prettyprint">isolated</code> argument changes the execution method so that each example is executed in a brand new instance of the Specification:</p>
<pre><code class="prettyprint">  class IsolatedSpec extends mutable.Specification {
    isolated

    &quot;Each example should be executed in isolation&quot; &gt;&gt; {

      val tree = new Tree(1, 2, 3, 4)
      &quot;the first example modifies the tree&quot; &gt;&gt; {
        tree.removeNodes(2, 3) must have size(2)
      }
      &quot;the second example gets an unmodified version of the tree&quot; &gt;&gt; {
        tree.removeNodes(2, 3, 4) must have size(1)
      }
    }
  }
</code></pre><p>Since there is a new Specification for each example, then all the variables accessible to the example will be seen as new.</p><p><em>Note</em>: this technique will not work if the Specification is defined with a constructor having parameters because it won't be possible to create a new instance.</p><a name="Case+classes"><h5>Case classes</h5></a><p>The same kind of variable isolation can be achieved in acceptance specifications by using case classes:</p>
<pre><code class="prettyprint">  class ContextSpec extends Specification { def is =
    &quot;this is the first example&quot; ! trees().e1 ^
    &quot;this is the first example&quot; ! trees().e2
  }

  case class trees() {
    val tree = createATreeWith4Nodes

    def e1 = tree.removeNodes(2, 3) must have size(2)
    def e2 = tree.removeNodes(2, 3, 4) must have size(1)
  }
</code></pre><p>In this case we don't need to extend the <code class="prettyprint">Scope</code> trait because the examples <code class="prettyprint">e1</code> and <code class="prettyprint">e2</code> already return <code class="prettyprint">Result</code>s.</p><a name="Contexts+inheritance"><h5>Contexts inheritance</h5></a><p>One very cool property of using traits to define context variables is that we can use inheritance to describe more and more specific contexts:</p>
<pre><code class="prettyprint">  trait LoggedIn extends Scope {
    val user = logInUser
    // do something with the user
  }

  trait HasAPendingOrder extends LoggedIn {
    val order = createPendingOrder
    // the user is logged in
    // now do something with the user and his order
  }
</code></pre><a name="Before%2FAfter"><h4>Before/After</h4></a><p>If you want to run some code before or after each example, the <code class="prettyprint">Before</code> and <code class="prettyprint">After</code> traits are there to help you (they both extend the <code class="prettyprint">Scope</code> trait). In the following examples we'll only show the use of <code class="prettyprint">After</code> because <code class="prettyprint">Before</code> most of the time unnecessary:</p>
<pre><code class="prettyprint">  class ContextSpec extends mutable.Specification {
    &quot;this is the first example&quot; in new trees {
      tree.removeNodes(2, 3) must have size(2)
    }
    &quot;this is the first example&quot; in new trees {
      tree.removeNodes(2, 3, 4) must have size(1)
    }
  }

  trait trees extends Scope {
    setupDB
    lazy val tree = getATreeWith4NodesFromTheDatabase
  }
</code></pre><p>Indeed when you have setup code you can do anything you want in the body of your context trait and this will be executed before the example body. However this wouldn't work with teardown code, so let's see how to use the <code class="prettyprint">After</code> trait.</p><a name="In+a+mutable+specification"><h5>In a mutable specification</h5></a><p>You make your context trait extend the <code class="prettyprint">mutable.After</code> trait:</p>
<pre><code class="prettyprint">  class ContextSpec extends mutable.Specification {
    &quot;this is the first example&quot; in new trees {
      tree.removeNodes(2, 3) must have size(2)
    }
    &quot;this is the first example&quot; in new trees {
      tree.removeNodes(2, 3, 4) must have size(1)
    }
  }

  trait trees extends mutable.After {
    lazy val tree = getATreeWith4NodesFromTheDatabase
    def after = cleanupDB
  }
</code></pre><p>In this case, the clean-up code defined in the <code class="prettyprint">after</code> method will be executed after each example. This is possible because the <code class="prettyprint">mutable.After</code> trait extends the Scala <code class="prettyprint">DelayedInit</code> trait allowing to insert code around the execution of the body of an object.</p><p><strong>Note</strong>: the <code class="prettyprint">org.specs2.mutable.{ Before, After, BeforeAfter }</code> traits only work for scala &gt; 2.9.0 because previous Scala versions don't provide the <code class="prettyprint">DelayedInit</code> trait.</p><a name="In+an+acceptance+specification"><h5>In an acceptance specification</h5></a><p>In that case you would extend the <code class="prettyprint">specification.After</code> trait and use the <code class="prettyprint">apply</code> method:</p>
<pre><code class="prettyprint">  class ContextSpec extends Specification { def is =
    &quot;this is the first example&quot; ! trees().e1 ^
    &quot;this is the first example&quot; ! trees().e2

    case class trees() extends specification.After {
      lazy val tree = getATreeWith4NodesFromTheDatabase
      def after = cleanupDB

      // this is equivalent to: def e1 = this.apply { ... }
      def e1 = this { tree.removeNodes(2, 3) must have size(2) }
      def e2 = this { tree.removeNodes(2, 3, 4) must have size(1) }
    }
  }
</code></pre><p>Now we have both variable isolation and non-duplication of set-up code!</p><p>But there is more to it. The next paragraphs will show how to:</p>
<ol>
  <li>execute the body of each example inside a specific context: <code class="prettyprint">Around</code></li>
  <li>set-up a context object (say a http query) and pass it to each example: <code class="prettyprint">Outside</code></li>
  <li>declare a <code class="prettyprint">before</code> method for all the examples of a Specification without even having to create a context object</li>
  <li>use an implicit context to avoid duplication</li>
  <li>create a new context object by combining existing ones</li>
</ol><a name="Around"><h4>Around</h4></a><p>Some examples need to be executed in a given context. For example you're testing a web application and your specification code needs to have your example executed inside an Http session.</p><p>In that case you can extend the <code class="prettyprint">Around</code> trait and specify the <code class="prettyprint">around</code> method:</p>
<pre><code class="prettyprint">  object http extends Around {
    def around[T &lt;% Result](t: =&gt;T) = openHttpSession(&quot;test&quot;) {
      t  // execute t inside a http session
    }
  }

  &quot;this is a first example where the code executes inside a http session&quot; ! http(e1)
  &quot;and another one&quot;                                                       ! http(e2)
</code></pre><p>Note that the context here is an object instead of a trait or case class instance because in this specification we don't need any variable isolation. We also take the advantage that objects extending <code class="prettyprint">Context</code> traits (like <code class="prettyprint">Before</code> / <code class="prettyprint">After</code> / <code class="prettyprint">Around</code>,...) have an <code class="prettyprint">apply</code> method so we can directly write <code class="prettyprint">http(e1)</code> meaning <code class="prettyprint">http.apply(e1)</code>.</p><a name="Outside"><h4>Outside</h4></a><p><code class="prettyprint">Outside</code> is bit like <code class="prettyprint">Around</code> except that you can get access to the application state that you're setting in your Context object. Let's see that with an example (with a mutable Specification for a change):</p>
<pre><code class="prettyprint">  object http extends Outside[HttpReq] with Scope {
    // prepare a valid HttpRequest
    def outside: HttpReq = createRequest
  }

  // use the http request in each example
  &quot;this is a first example where the code executes uses a http request&quot; in http { (request: HttpReq) =&gt;
    success
  }
  &quot;and another one&quot; in http { (request: HttpReq) =&gt;
    success
  }
</code></pre><a name="AroundOutside"><h5>AroundOutside</h5></a><p>We can also combine both the <code class="prettyprint">Around</code> and the <code class="prettyprint">Outside</code> behaviors with the <code class="prettyprint">AroundOutside</code> trait:</p>
<pre><code class="prettyprint">  object http extends AroundOutside[HttpReq] {
    // create a context
    def around[T &lt;% Result](t: =&gt;T) = {
      createNewDatabase
      // execute the code inside a databaseSession
      inDatabaseSession { t }
    }
    // prepare a valid HttpRequest
    def outside: HttpReq = createRequest
  }

  &quot;this is a first example where the code executes uses a http request&quot; ! http((request: HttpReq) =&gt; success)
  &quot;and another one&quot;                                                     ! http((request: HttpReq) =&gt; success)
</code></pre><a name="BeforeExample"><h4>BeforeExample</h4></a><p>When you just need to have set-up code executed before each example and if you don't need to have variable isolation, you can simply use the <code class="prettyprint">BeforeExample</code> trait.</p><p>The <code class="prettyprint">BeforeExample</code> trait allows you to define a <code class="prettyprint">before</code> method exactly like the one you define in the <code class="prettyprint">Before</code> trait and apply it to all the examples of the specification:</p>
<pre><code class="prettyprint">  class MySpecification extends mutable.Specification with BeforeExample {
    def before = cleanDatabase

    &quot;This is a specification where the database is cleaned up before each example&quot; &gt;&gt; {
      &quot;first example&quot; in { success }
      &quot;second example&quot; in { success }
    }
  }
</code></pre><p>As you can guess, the <code class="prettyprint">AfterExample</code>, <code class="prettyprint">AroundExample</code>,... traits work similarly by requiring the corresponding <code class="prettyprint">after</code>, <code class="prettyprint">around</code>,... methods to be defined.</p><a name="Implicit+context"><h4>Implicit context</h4></a><p>The <code class="prettyprint">BeforeExample</code> trait is a nice shortcut to avoid the creation of a context object, but there is another possibility to avoid the repetition of the context name for each example. If your specification is:</p>
<pre><code class="prettyprint">  class ContextSpec extends mutable.Specification {
    object myContext = new Before { def before = cleanUp }

    &quot;This is a specification where the database is cleaned up before each example&quot; &gt;&gt; {
      &quot;first example&quot; in myContext { 1 must_== 1 }
      &quot;second example&quot; in myContext { 1 must_== 1 }
    }
  }
</code></pre><p>You can simply mark your context object as <code class="prettyprint">implicit</code> and it will be automatically passed to each example:</p>
<pre><code class="prettyprint">  class ContextSpec extends mutable.Specification {
    implicit object myContext = new Before { def before = cleanUp }

    &quot;This is a specification where the database is cleaned up before each example&quot; &gt;&gt; {
      &quot;first example&quot;  in { 1 must_== 1 }
      &quot;second example&quot; in { 1 must_== 1 }
    }
  }
</code></pre><p>There is just one gotcha that you need to be aware of. If your implicit context is an <code class="prettyprint">Outside[String]</code> context this will not work:</p>
<pre><code class="prettyprint">  class ContextSpec extends mutable.Specification {
    implicit object myContext = new Outside[String] { def outside = &quot;hello&quot; }

    &quot;This is a specification uses a new String in each example&quot; &gt;&gt; {
      &quot;first example&quot;  in { (s: String) =&gt; s must_== s }
      &quot;second example&quot; in { (s: String) =&gt; s must_== s }
    }
  }
</code></pre><p>Indeed in both examples above the <code class="prettyprint">s</code> string that will be passed is the Example description as specified <a href="#Use+descriptions">here</a>.</p><a name="Composition"><h4>Composition</h4></a><a name="Combinations"><h5>Combinations</h5></a><p><strong><em>specs2</em></strong> contexts can be combined in several ways. When you want to define both <code class="prettyprint">Before</code> and <code class="prettyprint">After</code> behavior, you can do it by simply extending those 2 traits:</p>
<pre><code class="prettyprint">   case class withFile extends Before with After {
     def before = createFile(&quot;test&quot;)
     def after  = deleteFile(&quot;test&quot;)
   }
</code></pre><p>But, as we've seen with the <code class="prettyprint">AroundOutside</code> example, <strong><em>specs2</em></strong> likes to help save keystrokes so you can directly extend the <code class="prettyprint">BeforeAfter</code> trait:</p>
<pre><code class="prettyprint">   case class withFile extends BeforeAfter {
     def before = createFile(&quot;test&quot;)
     def after  = deleteFile(&quot;test&quot;)
   }
</code></pre><p>Similarly you can use <code class="prettyprint">BeforeAfterAround</code> instead of <code class="prettyprint">Before with After with Around</code>.</p><a name="Composition"><h5>Composition</h5></a><p>Contexts can be also be <em>composed</em> but only if they are of the same type, <code class="prettyprint">Before</code> with <code class="prettyprint">Before</code>, <code class="prettyprint">After</code> with <code class="prettyprint">After</code>,...</p>
<pre><code class="prettyprint">  case class withFile extends Before {
    def before = createFile(&quot;test&quot;)
  }
  case class withDatabase extends Before {
    def before = openDatabase(&quot;test&quot;)
  }
  val init = withFile() compose withDatabase()

  &quot;Do something on the full system&quot; ! init(success)
</code></pre><a name="Steps%2FActions"><h4>Steps/Actions</h4></a><a name="Steps"><h5>Steps</h5></a><p>Some set-up actions are very time-consuming and should be executed only once for the whole specification. This can be achieved by inserting some silent <code class="prettyprint">Step</code>s in between fragments:</p>
<pre><code class="prettyprint">  class DatabaseSpec extends Specification { def is =

    &quot;This specification opens a database and execute some tests&quot;     ^ Step(openDatabase) ^
      &quot;example 1&quot;                                                    ! success ^
      &quot;example 2&quot;                                                    ! success ^
                                                                     Step(closeDatabase)^
                                                                     end
  }
</code></pre><p>The examples are (by default) executed concurrently between the 2 steps and the &quot;result&quot; of those steps will never be reported unless if there is a failure.</p><a name="Actions"><h5>Actions</h5></a><p><code class="prettyprint">Step</code>s are very useful because they will really be executed sequentially, before anything else, but if you need to execute some actions which are completely independent of the rest of the specification, there is an equivalent to <code class="prettyprint">Step</code> adequately called <code class="prettyprint">Action</code>:</p>
<pre><code class="prettyprint">  class DatabaseSpec extends Specification { def is =

    &quot;This specification opens a database and execute some tests&quot;     ^ Step(openDatabase) ^
      &quot;example 1&quot;                                                    ! success ^
      &quot;add 1 to the number of specification executions&quot;              ^ Action(db.executionsNb += 1)^
      &quot;example 2&quot;                                                    ! success ^
                                                                     Step(closeDatabase)^
                                                                     end
  }
</code></pre><p>Of course, <code class="prettyprint">Step</code>s and <code class="prettyprint">Action</code>s are not the privilege of acceptance specifications:</p>
<pre><code class="prettyprint">  class DatabaseSpec extends mutable.Specification {

    textFragment(&quot;This specification opens a database and execute some tests&quot;)
    step(openDatabase)

    &quot;example 1&quot; in success

    textFragment(&quot;add 1 to the number of specification executions&quot;)
    action(db.executionsNb += 1)

    &quot;example 2&quot; in success
    step(closeDatabase)
  }
</code></pre><a name="Template"><h4>Template</h4></a><p>There may still be some duplication of code if you have to use the same kind of set-up procedure for several specifications.</p><p>If that's the case you can define your own <code class="prettyprint">Specification</code> trait doing the job:</p>
<pre><code class="prettyprint">  import org.specs2._
  import specification._

  trait DatabaseSpec extends Specification {
    /** the map method allows to &quot;post-process&quot; the fragments after their creation */
    override def map(fs: =&gt;Fragments) = Step(startDb) ^ fs ^ Step(cleanDb)
  }
</code></pre><p>The <code class="prettyprint">DatabaseSpec</code> above will insert, in each inherited specification, one <code class="prettyprint">Step</code> executed before all the fragments, and one executed after all of them.</p><a name="Execution"><h3>Execution</h3></a><p>This section summarizes the execution algorithm of a specification based on its fragments:</p>
<ol>
  <li>all the fragments are divided into groups delimited by <code class="prettyprint">Steps</code></li>
  <li>if the <code class="prettyprint">sequential</code> argument is present, each fragment goes to its own group</li>
  <li>groups are executed sequentially and all the fragments of a given group are executed concurrently</li>
  <li>if the <code class="prettyprint">isolated</code> argument is present, each example is executed in its own version of the Specification</li>
  <li>if the <code class="prettyprint">isolated</code> argument is present, all the <code class="prettyprint">Steps</code> preceding an example are executed before that example</li>
  <li>if the Specification inherits from the <code class="prettyprint">AllExpectations</code> trait, then it is executed as an <code class="prettyprint">isolated</code> Specification unless it is already set as <code class="prettyprint">sequential</code></li>
</ol><a name="Layout"><h3>Layout</h3></a><p>For an <em>acceptance</em> specification you can tweak the layout of Texts and Examples.</p><a name="Rules"><h5>Rules</h5></a><p>The layout of text in <strong><em>specs2</em></strong> is mostly done automatically so that the text in the source code should look like the displayed text after execution.</p><p>By default the layout of a specification will be computed automatically based on intuitive rules:</p>
<ul>
  <li>when an example follows a text, it is indented</li>
  <li>2 successive examples will be at the same indentation level</li>
  <li>when a text follows an example, this means that you want to describe a &quot;subcontext&quot;, so the next examples will be indented with one more level</li>
</ul><p>Let's see a standard example of this. The following fragments:</p>
<pre><code class="prettyprint">   &quot;this is some presentation text&quot;      ^
     &quot;and the first example&quot;             ! success^
     &quot;and the second example&quot;            ! success
</code></pre><p>will be executed and displayed as:</p>
<pre><code class="prettyprint">   this is some presentation text
   + and the first example
   + and the second example
</code></pre><p>If you specify a &quot;subcontext&quot;, you will get one more indentation level:</p>
<pre><code class="prettyprint">  &quot;this is some presentation text&quot;      ^
    &quot;and the first example&quot;             ! success^
    &quot;and the second example&quot;            ! success^
    &quot;and in this specific context&quot;      ^
      &quot;one more example&quot;                ! success^
</code></pre><p>will be executed and displayed as:</p>
<pre><code class="prettyprint">  this is some presentation text
  + and the first example
  + and the second example
    and in this specific context
    + one more example
</code></pre><a name="Formatting+fragments"><h5>Formatting fragments</h5></a><p>Given the rules above, you might need to use some <em>formatting fragments</em> to adjust the display</p><a name="Separating+groups+of+examples"><h6>Separating groups of examples</h6></a><p>The best way to separate blocks of examples is to add a blank line between them by using <code class="prettyprint">p</code> (as in &quot;paragraph&quot;):</p>
<pre><code class="prettyprint">  &quot;this is some presentation text&quot;      ^
    &quot;and the first example&quot;             ! success^
    &quot;and the second example&quot;            ! success^
                                        p^
  &quot;And another block of examples&quot;       ^
    &quot;with this example&quot;                 ! success^
    &quot;and that example&quot;                  ! success
</code></pre><p>This will be displayed as:</p>
<pre><code class="prettyprint">  this is some presentation text
  + and the first example
  + and the second example

  And another block of examples
  + with this example
  + and that example
</code></pre><p>That looks remarkably similar to the specification code, doesn't it? What <code class="prettyprint">p</code> does is:</p>
<ul>
  <li>add a blank line (this can also be done with a simple <code class="prettyprint">br</code>)</li>
  <li>decrement the current indentation level by 1 (Otherwise the new Text would be seen as a subcontext)</li>
</ul><a name="Reset+the+levels"><h6>Reset the levels</h6></a><p>When you start having deep levels of indentation, you might need to start the next group of examples at level 0. For example, in this specification</p>
<pre><code class="prettyprint">  &quot;There are several options for displaying the text&quot;      ^
    &quot;xonly displays nothing but failures&quot;                  ! success^
    &quot;there is also a color option&quot;                         ^
      &quot;rgb=value uses that value to color the text&quot;        ! rgb^
      &quot;nocolor dont color anything&quot;                        ! nocolor^
                                                           p^
  &quot;There are different ways of hiding the text&quot;            ^
      &quot;by tagging the text&quot;                                ! hideTag
</code></pre><p>Even with <code class="prettyprint">p</code> the next group of examples will not start at level 0. What you need to do in that case is use <code class="prettyprint">end</code>:</p>
<pre><code class="prettyprint">  &quot;There are several options for displaying the text&quot;      ^
    &quot;xonly displays nothing but failures&quot;                  ! success^
    &quot;there is also a color option&quot;                         ^              // this text will be indented
      &quot;rgb=value uses that value to color the text&quot;        ! rgb^         // and the following examples as well
      &quot;nocolor dont color anything&quot;                        ! nocolor^
                                                           end^
  &quot;There are different ways of hiding the text&quot;            ^              // this text will be properly indented now
    &quot;by tagging the text&quot;                                  ! hideTag^
                                                           end
</code></pre><p>This will be displayed as:</p>
<pre><code class="prettyprint">  There are several options for displaying the text
  + xonly displays nothing but failures
    there is also a color option
    + rgb=value uses that value to color the text
    + nocolor dont color anything
  There are different ways of hiding the text
  + by tagging the text
</code></pre><p>And if you want to reset the indentation level <em>and</em> add a blank line you can use <code class="prettyprint">end ^ br</code> (or <code class="prettyprint">endbr</code> as seen in &quot;Combinations&quot; below).</p><a name="Changing+the+indentation+level"><h6>Changing the indentation level</h6></a><p>If, for whatever reason, you wish to have more or less indentation, you can use the <code class="prettyprint">t</code> and <code class="prettyprint">bt</code> fragments (as in &quot;tab&quot; and &quot;backtab&quot;):</p>
<pre><code class="prettyprint">  &quot;this text&quot;                                     ^ bt^
  &quot;doesn't actually have an indented example&quot;     ! success

  &quot;this text&quot;                                     ^ t^
      &quot;has a very indented example&quot;               ! success
</code></pre><p>The number of indentation levels (characterized as 2 spaces on screen) can also be specified by using <code class="prettyprint">t(n)</code> or <code class="prettyprint">bt(n)</code>.</p><a name="Combinations"><h6>Combinations</h6></a><p>Some formatting elements can be combined:</p>
<ul>
  <li><code class="prettyprint">p</code> is actually <code class="prettyprint">br ^ bt</code></li>
  <li><code class="prettyprint">endbr</code> is <code class="prettyprint">end ^ br</code></li>
  <li><code class="prettyprint">endp</code> is <code class="prettyprint">end ^ p</code> (same effect as <code class="prettyprint">endbr</code> but shorter :-))</li>
</ul><a name="Turning-off+the+automatic+layout"><h6>Turning-off the automatic layout</h6></a><p>You can turn off that automatic layout by adding the <code class="prettyprint">noindent</code> argument at the beginning of your specification:</p>
<pre><code class="prettyprint">  class MySpecWithNoIndent extends Specification {
    def is = noindent ^ ....
  }
</code></pre><a name="Unit+specification"><h6>Unit specification</h6></a><p>Formatting fragments can be used in a unit specification as well. 2 forms are supported, either as a single declaration:</p>
<pre><code class="prettyprint">  &quot;this is an example&quot; &gt;&gt; { 1 === 1 }
  p // add a paragraph
  &quot;this is another example&quot; &gt;&gt; { 2 === 2 }
</code></pre><p>Or as a postfix operator on fragments:</p>
<pre><code class="prettyprint">  &quot;this is some text and a paragraph&quot;.p
  &quot;this is an example and a paragraph&quot; &gt;&gt; {
    1 must_== 1
  } p
</code></pre><p>There are also 2 additional postfix operations which can be used to start new paragraphs. Instead of using <code class="prettyprint">endp</code> to end a group of examples and starte a new one:</p>
<pre><code class="prettyprint">  &quot;This is a first block of examples&quot;.p
  { 1 === 1 }.eg;
  { 2 === 2 }.eg.endp

  &quot;And a second block&quot;.p
  { 3 === 3 }.eg;
  { 4 === 4 }.eg
</code></pre><p>You can use <code class="prettyprint">newp</code> (or <code class="prettyprint">newbr</code>) to the same effect:</p>
<pre><code class="prettyprint">  &quot;This is a first block of examples&quot;.p
  { 1 === 1 }.eg;
  { 2 === 2 }.eg

  &quot;And a second block&quot;.newp
  { 3 === 3 }.eg;
  { 4 === 4 }.eg
</code></pre><p>A shortcut is also available to indent a 'subexample' locally:</p>
<pre><code class="prettyprint">  &quot;this is the first major example&quot; &gt;&gt; { ok }
      &quot;this is minor and should be indented&quot; &gt;&gt; { ok } lt;
    &quot;this is the second major example&quot; &gt;&gt; { ok }
  }
</code></pre><p>This will output:</p>
<pre><code class="prettyprint">  this is a group of examples
  + this is the first major example
    + this is minor and should be indented
  + this is the second major example
</code></pre><a name="Unit+specifications"><h3>Unit specifications</h3></a><p>Those are all the methods which you can use to create fragments in a unit specification:</p>
<ul>
  <li><p><code class="prettyprint">can</code>: create a group of Examples, with the preceding Text fragment appended with <code class="prettyprint">can</code></p>
  <pre><code class="prettyprint">&quot;a configuration&quot; can {
  &quot;have a name&quot; in { ... }
}
</code></pre></li>
  <li><p><code class="prettyprint">&gt;</code><code class="prettyprint">&gt;</code>: create an Example or a group of Examples (with no appended text)</p>
  <pre><code class="prettyprint">&quot;a configuration may&quot; &gt;&gt; {
  &quot;have a name&quot; in { ... }
}
</code></pre></li>
  <li><p><code class="prettyprint">title</code>: give a title to the Specification</p>
  <pre><code class="prettyprint">&quot;My spec title&quot;.title
// file path can be used to specify a different path for the html reporting
&quot;My spec title&quot;.title(filePath = &quot;com/MySpec.html&quot;)
</code></pre></li>
  <li><p><code class="prettyprint">args</code>: create arguments for the specification</p></li>
  <li><p><code class="prettyprint">.txt</code> or <code class="prettyprint">textFragment</code>: create a <code class="prettyprint">Text</code> fragment</p>
  <pre><code class="prettyprint">&quot;this is a text fragment&quot;.txt

textFragment(&quot;this is a text fragment&quot;)
</code></pre></li>
  <li><p><code class="prettyprint">step</code>: create a <code class="prettyprint">Step</code></p>
  <pre><code class="prettyprint">step { initializeDatabase() }
</code></pre></li>
  <li><p><code class="prettyprint">action</code>: create an <code class="prettyprint">Action</code></p>
  <pre><code class="prettyprint">action { justDoIt }
</code></pre></li>
  <li><p><code class="prettyprint">link</code>: create a link to another specification</p>
  <pre><code class="prettyprint">link(&quot;how&quot; ~ (&quot;to do hello world&quot;, new HelloWorldSpec))
</code></pre></li>
  <li><p><code class="prettyprint">see</code>: add a link to another specification without including its fragments for execution</p>
  <pre><code class="prettyprint">see(new HelloWorldSpec)
</code></pre></li>
  <li><p><code class="prettyprint">include</code> to include another specification</p>
  <pre><code class="prettyprint">include(new HelloWorldSpec)
</code></pre></li>
  <li><p><code class="prettyprint">p, br, t, bt, end, endp</code>: add a formatting fragment</p></li>
</ul><p>To make things more concrete here is a full example:</p>
<pre><code class="prettyprint">  import mutable._
  import specification._
  import execute.Success

  /**
   * This specification shows how to use the mutable.Specification trait to create a unit Specification
   * where the fragments are built using a mutable variable
   */
  class MutableSpec extends Specification {

    // A title can be added at the beginning of the specification
    &quot;MutableSpec&quot;.title
    // arguments are simply declared at the beginning of the specification if needed
    args(xonly=true)

    &quot;This is a unit specification showing the use of different methods&quot;.txt

    // a step to execute before the specification must be declared first
    step {
      // setup your data or initialize your database here
      success
    }

    &quot;'Hello world'&quot; should {
      &quot;contain 11 characters&quot; in {
        &quot;Hello world&quot; must have size(11)
      }
      &quot;start with 'Hello'&quot; in {
        &quot;Hello world&quot; must startWith(&quot;Hello&quot;)
      }
      /**
       * a failing example will stop right away, without having to &quot;chain&quot; expectations
       */
      &quot;with 'world'&quot; in {
        // Expectations are throwing exception by default so uncommenting this line will
        // stop the execution right away with a Failure
        // &quot;Hello world&quot; must startWith(&quot;Hi&quot;)

        &quot;Hello world&quot; must endWith(&quot;world&quot;)
      }
    }
    /**
     * &quot;Context management&quot; is handled through the use of traits or case classes
     */
    &quot;'Hey you'&quot; should {
      // this one uses a &quot;before&quot; method
      &quot;contain 7 characters&quot; in context {
        &quot;Hey you&quot; must have size(7)
      }
      // System is a Success result. If the expectations fail when building the object, the example will fail
      &quot;contain 7 characters&quot; in new system {
        string must have size(7)
      }
      // otherwise a case class can be used but the example body will be further down the file
      &quot;contain 7 characters&quot; in system2().e1
    }
    // you can add links to other specifications with `link`
    // they will be executed when this one is executed. If you don't want this to happen
    // you can use `see` instead of `link`
    link(&quot;how&quot; ~ (&quot;to do hello world&quot;, new HelloWorldSpec))
    // you can include other specifications with `include`
    include(new HelloWorldSpec)

    // a step to execute after the specification must be declared at the end
    step {
      // close the database here
      success
    }


    object context extends Before {
      def before = () // do something to setup the context
    }
    // we need to extend Scope to be used as an Example body
    trait system extends Scope {
      val string = &quot;Hey you&quot;
    }
    case class system2() {
      val string = &quot;Hey you&quot;
      def e1 = string must have size(7)
    }
  }
</code></pre><a name="How+to%3F"><h3>How to?</h3></a><a name="Declare+arguments"><h4>Declare arguments</h4></a><p>Arguments are usually passed on the command line but you can also declare them at the beginning of the specification, to be applied only to that specification.<br />For example, you can turn off the concurrent execution of examples with the <code class="prettyprint">args(sequential=true)</code> call:</p>
<pre><code class="prettyprint">  class ExamplesOneByOne extends Specification { def is =

    // there is a shortcut for this argument called 'sequential'
    args(sequential=true)              ^
    &quot;first example&quot;                    ! e1 ^
    &quot;the the second one&quot;               ! e2 ^
                                       end
  }
</code></pre><p>For the complete list of arguments and shortcut methods read the <a href="org.specs2.guide.Runners.html">Runners</a> page.</p><a name="Pass+arguments"><h4>Pass arguments</h4></a><p>Some specifications can depend on the arguments passed on the command line, for example to fine-tune the behaviour of some Context objects. If you need to do this, you can add an <code class="prettyprint">Arguments</code> parameter to the Specification class. This parameter will be setup when the specification is instantiated:</p>
<pre><code class="prettyprint">  class DependOnCommandLine(args: Arguments) extends mutable.Specification {
    skipAllUnless(!args.commandLine.contains(&quot;DB&quot;))
    &quot;database access&quot; &gt;&gt; { dbAccess must beOk }
  }
</code></pre><p>Alternatively, if you need to keep your specification as a trait, you can mix-in the <code class="prettyprint">org.specs2.main.CommandLineArguments</code> trait. This trait has an <code class="prettyprint">arguments</code> variable which will contain the command-line arguments:</p>
<pre><code class="prettyprint">  class CommandedSpecification extends mutable.Specification with CommandLineArguments {
    if (arguments.sequential) &quot;this is&quot; &gt;&gt; ok
    else                      &quot;this is&quot; &gt;&gt; ko
  }
</code></pre><p>Note that the <code class="prettyprint">arguments</code> instance gives you access to all the specs2 arguments values like <code class="prettyprint">sequential</code> but also to any of your own command line argument values:</p>
<ul>
  <li><code class="prettyprint">arguments.commandLine.value(&quot;tag&quot;): Option[String]</code></li>
  <li><code class="prettyprint">arguments.commandLine.int(&quot;timeout&quot;): Option[Int]</code></li>
  <li><code class="prettyprint">arguments.commandLine.boolean(&quot;integration&quot;): Boolean</code></li>
</ul><a name="Add+a+title"><h4>Add a title</h4></a><p>Usually the title of a specification is derived from the specification class name. However if you want to give a more readable name to your specification report you can do the following:</p>
<pre><code class="prettyprint">  class MySpec extends Specification { def is =
     &quot;My beautiful specifications&quot;.title                           ^
                                                                   p^
     &quot;The rest of the spec goes here&quot;                              ^ end
  }
</code></pre><p>The title can be defined either:</p>
<ul>
  <li>at the beginning of the specification</li>
  <li>just after the arguments of the specification</li>
</ul><a name="Use+descriptions"><h4>Use descriptions</h4></a><p>The description of an Example can be used to create an expectation in the example body:</p>
<pre><code class="prettyprint">  &quot;This is a long, long, long description&quot; ! ((s: String) =&gt; s.size must be_&gt;(10))
</code></pre><a name="Enhance+failures"><h4>Enhance failures</h4></a><p>Most of the time, the message displayed in the case of a matcher failure is clear enough. However a bit more information is sometimes necessary to get a better diagnostic on the value that's being checked. Let's say that you want to check a &quot;ticket list&quot;:</p>
<pre><code class="prettyprint">  // will fail with &quot;List(ticket1, ticket2) doesn't have size 3&quot; for example
  machine.tickets must have size(3) // machine is a user-defined object
</code></pre><p>If you wish to get a more precise failure message you can set an alias with the <code class="prettyprint">aka</code> method (<em>also known as</em>):</p>
<pre><code class="prettyprint">  // will fail with &quot;the created tickets 'List(ticket1, ticket2)' doesn't have size 3&quot;
  machine.tickets aka &quot;the created tickets&quot; must haveSize(3)
</code></pre><p>There is also a shortcut for <code class="prettyprint">value aka value.toString</code> which is simply <code class="prettyprint">value.aka</code>.</p><p>And when you want other ways to customize the description, you can use:</p>
<ul>
  <li><code class="prettyprint">post</code>: <code class="prettyprint">&quot;a&quot; post &quot;is the first letter&quot;</code> prints <code class="prettyprint">a is the first letter</code></li>
  <li><code class="prettyprint">as</code>: <code class="prettyprint">&quot;b&quot; as ((s:String) =&gt; &quot;a&quot;+s+&quot;c&quot;)</code> prints <code class="prettyprint">abc</code></li>
  <li><code class="prettyprint">showAs</code>: <code class="prettyprint">Seq(1, 2, 3, 4).showAs((_:Seq[Int]).filter(isEven).mkString(&quot;|&quot;))</code> prints <code class="prettyprint">2|4</code>. This one is especially useful to filter out big data structures (lists, maps, xml...) before the failure display</li>
</ul><a name="Share+examples"><h4>Share examples</h4></a><p>In a given specification some examples may look similar enough that you would like to &quot;factor&quot; them out and share them between<br />different parts of your specification. The best example of this situation is a specification for a Stack of limited size:</p>
<pre><code class="prettyprint">  class StackSpec extends Specification { def is =

    &quot;Specification for a Stack with a limited capacity&quot;.title                   ^
                                                                                p^
    &quot;A Stack with limited capacity can either be:&quot;                              ^ endp^
      &quot;1. Empty&quot;                                                                ^ anEmptyStack^
      &quot;2. Normal (i.e. not empty but not full)&quot;                                 ^ aNormalStack^
      &quot;3. Full&quot;                                                                 ^ aFullStack^end

    def anEmptyStack =                                                          p^
      &quot;An empty stack should&quot;                                                   ^
        &quot;have a size == 0&quot;                                                      ! empty().e1^
        &quot;throw an exception when sent #top&quot;                                     ! empty().e2^
        &quot;throw an exception when sent #pop&quot;                                     ! empty().e3^endbr

    def aNormalStack =                                                          p^
      &quot;A normal stack should&quot;                                                   ^
        &quot;behave like a non-empty stack&quot;                                         ^ nonEmptyStack(newNormalStack)^
        &quot;add to the top when sent #push&quot;                                        ! nonFullStack().e1^endbr

    def aFullStack =                                                            p^
      &quot;A full stack should&quot;                                                     ^
        &quot;behave like a non-empty stack&quot;                                         ^ nonEmptyStack(newFullStack)^
        &quot;throw an exception when sent #push&quot;                                    ! fullStack().e1

    def nonEmptyStack(stack: =&gt;SizedStack) = {                                  t^
      &quot;have a size &gt; 0&quot;                                                         ! nonEmpty(stack).size^
      &quot;return the top item when sent #top&quot;                                      ! nonEmpty(stack).top1^
      &quot;not remove the top item when sent #top&quot;                                  ! nonEmpty(stack).top2^
      &quot;return the top item when sent #pop&quot;                                      ! nonEmpty(stack).pop1^
      &quot;remove the top item when sent #pop&quot;                                      ! nonEmpty(stack).pop2^bt
    }

    /** stacks creation */
    def newEmptyStack  = SizedStack(maxCapacity = 10, size = 0)
    def newNormalStack = SizedStack(maxCapacity = 10, size = 2)
    def newFullStack   = SizedStack(maxCapacity = 10, size = 10)

    /** stacks examples */
    case class empty() {
      val stack = newEmptyStack

      def e1 = stack.size must_== 0
      def e2 = stack.top must throwA[NoSuchElementException]
      def e3 = stack.pop must throwA[NoSuchElementException]
    }

    def nonEmpty(createStack: =&gt;SizedStack) = new {
      val stack = createStack

      def size = stack.size &gt; 0

      def top1 = stack.top must_== stack.size
      def top2 = {
        stack.top
        stack.top must_== stack.size
      }

      def pop1 = {
        val topElement = stack.size
        stack.pop must_== topElement
      }

      def pop2 = {
        stack.pop
        stack.top must_== stack.size
      }
    }

    case class nonFullStack() {
      val stack = newNormalStack

      def e1 = {
        stack push (stack.size + 1)
        stack.top must_== stack.size
      }
    }
    case class fullStack() {
      val stack = newFullStack

      def e1 = stack push (stack.size + 1) must throwAn[Error]
    }
  }
</code></pre><a name="Create+an+index"><h4>Create an index</h4></a><p>Here's something you can do to automatically create an index page for your specifications:</p>
<pre><code class="prettyprint">  import org.specs2._
  import runner.SpecificationsFinder._

  class index extends Specification { def is =

    examplesLinks(&quot;Example specifications&quot;)

    // see the SpecificationsFinder trait for the parameters of the 'specifications' method
    def examplesLinks(t: String) = specifications().foldLeft(t.title) { (res, cur) =&gt; res ^ see(cur) }
  }
</code></pre><p>The specification above creates an index.html file in the <code class="prettyprint">target/specs2-reports</code> directory. The specifications method<br />creates specifications using the following parameters:</p>
<ul>
  <li><code class="prettyprint">path</code>: glob pattern to filter specification files. Default value is <code class="prettyprint">**/*.scala</code></li>
  <li><code class="prettyprint">pattern</code>: pattern to use when trying to retrieve the specification names from the source files. Default value = <code class="prettyprint">.*Spec</code></li>
  <li><code class="prettyprint">filter</code>: function to keep only some specifications depending on their name. Default value = <code class="prettyprint">(name: String) =&gt; true</code></li>
  <li><code class="prettyprint">basePath</code>: the path where to start the search. Default value: the <code class="prettyprint">specs2.srcTestDir</code> system value = <code class="prettyprint">src/test/scala</code></li>
  <li><code class="prettyprint">verbose</code>: boolean indicating if information about finding files and specifications must be printed. Default value = <code class="prettyprint">false</code></li>
</ul><a name="Tag+examples"><h4>Tag examples</h4></a><p>Tags can be used in a Specification to include or exclude some examples or a complete section of fragments from the execution. Let's have a look at one example:</p>
<pre><code class="prettyprint">  /**
   * use the org.specs2.specification.Tags trait to define tags and sections
   */
  class TaggedSpecification extends Specification with Tags { def is =
    &quot;this is some introductory text&quot;                          ^
    &quot;and the first group of examples&quot;                         ^
      &quot;example 1&quot;                                             ! success ^ tag(&quot;feature 1&quot;, &quot;unit&quot;)^
      &quot;example 2&quot;                                             ! success ^ tag(&quot;integration&quot;)^
                                                              ^ p^
    &quot;and the second group of examples&quot;                        ^          section(&quot;checkin&quot;)^
      &quot;example 3&quot;                                             ! success^
      &quot;example 4&quot;                                             ! success^ section(&quot;checkin&quot;)
  }
</code></pre><p>In that specification we're defining several tags and sections:</p>
<ul>
  <li><code class="prettyprint">feature 1</code> is a tag that's applied to <code class="prettyprint">example1</code> (the <em>preceding</em> Fragment)</li>
  <li><code class="prettyprint">feature 2</code> is a tag that's applied to <code class="prettyprint">example2</code> (the <em>preceding</em> Fragment)</li>
  <li><code class="prettyprint">checkin</code> marks a section which goes from the Text <code class="prettyprint">and the second group of examples</code> to <code class="prettyprint">example 4</code></li>
</ul><p>Armed with this, it is now easy to include or exclude portions of the specification at execution time:</p>
<ul>
  <li><code class="prettyprint">args(include=&quot;feature 1&quot;)</code> will only include <code class="prettyprint">example 1</code></li>
  <li><code class="prettyprint">args(exclude=&quot;integration&quot;)</code> will include everything except <code class="prettyprint">example 2</code></li>
  <li><code class="prettyprint">args(include=&quot;checkin,unit&quot;)</code> will include <code class="prettyprint">example 1</code> and the second group of examples (<code class="prettyprint">example 3</code> and <code class="prettyprint">example 4</code>)</li>
</ul><a name="In+a+unit+specification"><h5>In a unit specification</h5></a><p>A <em>unit</em> specification will accept the same <code class="prettyprint">tag</code> and <code class="prettyprint">section</code> methods but the behavior will be slightly different:</p>
<pre><code class="prettyprint">  import org.specs2.mutable._

  /**
   * use the org.specs2.mutable.Tags trait to define tags and sections
   */
  class TaggedSpecification extends Specification with Tags {
    &quot;this is some introductory text&quot; &gt;&gt; {
      &quot;and the first group of examples&quot; &gt;&gt; {
        tag(&quot;feature 1&quot;, &quot;unit&quot;)
        &quot;example 1&quot; in success
        &quot;example 2&quot; in success tag(&quot;integration&quot;)

      }
    }
    section(&quot;checkin&quot;)
    &quot;and the second group of examples&quot; &gt;&gt; {
      &quot;example 3&quot; in success
      &quot;example 4&quot; in success
    }
    section(&quot;checkin&quot;)

    &quot;and the last group of examples&quot; &gt;&gt; {
      &quot;example 5&quot; in success
      &quot;example 6&quot; in success
    } section(&quot;slow&quot;)
  }
</code></pre><p>For that specification above:</p>
<ul>
  <li><p>when the <code class="prettyprint">tag</code> call is inserted on a new line, the tagged fragment is the one just <em>after</em> the tag method call: <code class="prettyprint">example 1</code><br /> is tagged with <code class="prettyprint">feature1 and unit</code>,</p></li>
  <li><p>when the <code class="prettyprint">tag</code> is appended to an example, it applies to that example: <code class="prettyprint">example 2</code> is tagged with <code class="prettyprint">integration</code></p></li>
  <li><p>when the <code class="prettyprint">section</code> call is inserted on a new line, this opens a section for all the following fragments. This should<br /> be closed by a corresponding <code class="prettyprint">section</code> call on a new line. For example, <code class="prettyprint">example 3</code> and <code class="prettyprint">example 4</code> are part of the<br /> &quot;checkin&quot; section</p></li>
  <li><p>when the <code class="prettyprint">section</code> call is appended to a block of Fragments on the same line, all the fragments of that block are part of<br /> the section: <code class="prettyprint">example 5</code> and <code class="prettyprint">example 6</code> are tagged with <code class="prettyprint">slow</code></p></li>
</ul><a name="Skip+examples"><h4>Skip examples</h4></a><p>You can skip all the examples of a specification by using the <code class="prettyprint">skipAllIf</code> or <code class="prettyprint">skipAllUnless</code> methods:</p>
<pre><code class="prettyprint">  class EmailSpecification extends mutable.Specification {
    skipAllIf(serverIsOffLine)
    &quot;test email&quot; &gt;&gt; { sendEmail must beOk }
  }
</code></pre><a name="Debug+statements"><h4>Debug statements</h4></a><p>When quick and hacky <code class="prettyprint">println</code> statements are what you want, the <code class="prettyprint">Debug</code> trait, mixed in every <code class="prettyprint">Specification</code>, provides useful methods:</p>
<ul>
  <li><code class="prettyprint">pp</code> or &quot;print and pass&quot;, prints a value to the console, then return it to be used in the rest of the expression: &quot;graph.pp must haveSize(3)&quot;</li>
  <li><code class="prettyprint">pp(condition)</code> prints a value if a condition holds</li>
  <li><code class="prettyprint">pp(f: T =&gt; Boolean)</code> prints a value if a condition on that value holds</li>
</ul><a name="Remove+implicits"><h4>Remove implicits</h4></a><p>By default, the <code class="prettyprint">Specification</code> trait imports quite a few implicit definitions (following a &quot;batteries included&quot; approach). However there might be some conflicts with implicits existing in your own user code. Among the usual examples of conflicts are conflicts with the <code class="prettyprint">===</code> sign in Scalaz and the <code class="prettyprint">Duration</code> methods in Akka.</p><p>An easy way to avoid this situation is to &quot;deactivate&quot; the specs2 implicits by mixing-in the relevant trait from this list:</p>
<ul>
  <li><code class="prettyprint">org.specs2.control.NoDebug</code>: deactivate the <code class="prettyprint">pp</code> method on objects</li>
  <li><code class="prettyprint">org.specs2.time.NoTimeConversions</code>: deactivate the <code class="prettyprint">millis</code>, <code class="prettyprint">seconds</code>,... methods on <code class="prettyprint">Int</code>s and <code class="prettyprint">Long</code>s</li>
  <li><code class="prettyprint">org.specs2.main.NoArgProperties</code>: deactivate the <code class="prettyprint">toOption: Option[T]</code> method on any value of type <code class="prettyprint">T</code></li>
  <li><code class="prettyprint">org.specs2.matcher.NoCanBeEqual</code>: deactivate the <code class="prettyprint">===</code> method on any type <code class="prettyprint">T</code></li>
  <li><code class="prettyprint">org.specs2.matcher.NoMustExpectations</code>: deactivate the <code class="prettyprint">must</code>, <code class="prettyprint">must_==</code>,... methods on any value of type <code class="prettyprint">T</code></li>
  <li><code class="prettyprint">org.specs2.matcher.NoShouldExpectations</code>: deactivate the <code class="prettyprint">should</code>, <code class="prettyprint">should_==</code>,... methods on any value of type <code class="prettyprint">T</code></li>
  <li><code class="prettyprint">org.specs2.specification.NoAutoExamples</code>: deactivate the conversions from <code class="prettyprint">Boolean/Result/MatchResult/DataTable</code> to <code class="prettyprint">Fragment</code> or <code class="prettyprint">Example</code>. Specific versions of this trait can be selectively used, on either <code class="prettyprint">Boolean</code> or <code class="prettyprint">Result</code> or <code class="prettyprint">MatchResult</code> or <code class="prettyprint">DataTable</code>. For example: <code class="prettyprint">org.specs2.specification.NoBooleanAutoExamples</code> can be used to avoid the <code class="prettyprint">^</code> method being used on booleans</li>
  <li><code class="prettyprint">org.specs2.specification.NoFragmentsBuilder</code>: deactivate the implicit conversions from <code class="prettyprint">String</code> to <code class="prettyprint">Fragment</code>s</li>
  <li><code class="prettyprint">org.specs2.specification.mutable.NoFragmentsBuilder</code>: deactivate the implicit conversions from to remove <code class="prettyprint">in</code>, <code class="prettyprint">&gt;</code><code class="prettyprint">&gt;</code>, <code class="prettyprint">should</code> and <code class="prettyprint">can</code> methods from <code class="prettyprint">String</code>s</li>
</ul>
<hr /></div></status><status class="ok"><p></p></status></div><div id="rightcolumn"></div></body></html>